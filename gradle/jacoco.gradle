// ========== JACOCO SETUP - View the combined/merged report at: [project_root]/build/reports/jacoco/jacocoRootReport/html/index.html.
//                           Individual reports for each submodule can be found at: [project_root]/[submodule]/build/reports/jacoco/test/html/index.html
allprojects {
    apply plugin: 'jacoco'
    apply plugin: 'com.palantir.jacoco-coverage'

    jacoco {
        toolVersion = jacocoToolVersion
    }
}

ext {
    jacocoRootReportCoverageSummary = null
    jacocoCoverageSummaries = new LinkedHashMap<String, Double>()
}

// Tell subprojects to generate reports/data
subprojects {
    jacocoTestReport {
        additionalSourceDirs = files(sourceSets.main.allSource.srcDirs)
        sourceDirectories = files(sourceSets.main.allSource.srcDirs)
        classDirectories =  files(sourceSets.main.output)
        reports {
            html.enabled = true
            xml.enabled = true
            csv.enabled = false
        }
        afterEvaluate {
            classDirectories = files(classDirectories.files.collect {
                fileTree(dir: it, exclude: jacocoExclusions)
            })
        }
    }
}

configure(subprojectsToIncludeForJacocoComboReport(subprojects)) {
    jacocoTestReport {
        doLast { JacocoReport jr ->
            parseJacocoSummaryInfo(jr, false)
        }
    }
}

static def subprojectsToIncludeForJacocoComboReport(Set<Project> origSubprojects) {
    Set<Project> projectsToInclude = new HashSet<>()
    for (Project subproj : origSubprojects) {
        // For this project we'll include everything that's not a sample
        if (!subproj.getName().startsWith("sample")) {
            projectsToInclude.add(subproj)
        }
    }
    return projectsToInclude
}

// Do a root report to generate the combined report
//noinspection GroovyAssignabilityCheck
task jacocoRootReport(type: JacocoReport) {
    def subprojectsToInclude = subprojectsToIncludeForJacocoComboReport(subprojects)
    dependsOn = subprojectsToInclude.test
    additionalSourceDirs = files(subprojectsToInclude.sourceSets.main.allSource.srcDirs)
    sourceDirectories = files(subprojectsToInclude.sourceSets.main.allSource.srcDirs)
    classDirectories =  files(subprojectsToInclude.sourceSets.main.output)
    executionData = files(subprojectsToInclude.jacocoTestReport.executionData)
    reports {
        html.enabled = true
        xml.enabled = true
        csv.enabled = false
    }
    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: jacocoExclusions)
        })
    }
    onlyIf = {
        true
    }
    doFirst {
        executionData = files(executionData.findAll {
            it.exists()
        })
    }
    doLast { JacocoReport jr ->
        parseJacocoSummaryInfo(jr, true)
    }
}

def parseJacocoSummaryInfo(JacocoReport task, boolean isRootReport) {
    File xmlFile = task.reports.xml.destination
    if (xmlFile == null || !xmlFile.exists()) {
        return
    }

    Node rootNode = new XmlParser(false, false).parseText(
            xmlFile.text.replaceAll("<!DOCTYPE[^>]*>", "")
    )
    Double instructionPctCovered = null
    rootNode.counter.each { counter ->
        try {
            double missed = Integer.valueOf(counter.@missed as String).toDouble()
            double covered = Integer.valueOf(counter.@covered as String).toDouble()
            String type = counter.@type as String
            if (type == "INSTRUCTION") {
                instructionPctCovered = covered / (missed + covered)
            }
        } catch (ignore) {
        }
    }

    if (isRootReport) {
        jacocoRootReportCoverageSummary = instructionPctCovered
    }
    else {
        jacocoCoverageSummaries.put(task.project.name, instructionPctCovered)
    }
}

jacocoCoverageThresholdSetup()

// Output summaries for all the submodules' coverage when the build finishes
gradle.buildFinished {
    println("\nCoverage Summary:")

    println("${rootProject.name}: " + getCoveragePercentageAsString(jacocoRootReportCoverageSummary))

    jacocoCoverageSummaries.forEach({ String projectName, Double value ->
        println("${projectName}: " + getCoveragePercentageAsString(value))
    })
}

static String getCoveragePercentageAsString(Double pct) {
    if (pct == null) {
        return "??.?%"
    }

    return (pct * 100.0d).trunc(2) + "%"
}
